* sicp.js

Structure and Interpretation of Computer Programs, Comparison Edition

* 1 Building Abstractions with Procedures Functions

** 1.1 The Elements of Programming

[14]1.1.1 Expressions

[15]1.1.2 Naming and the Environment

[16]1.1.3 Evaluating Combinations Operator Combinations

[17]1.1.4 Compound Procedures Functions

[18]1.1.5 The Substitution Model for Procedure Function Application

[19]1.1.6 Conditional Expressions and Predicates

[20]1.1.7 Example: Square Roots by Newton's Method

[21]1.1.8 Procedures Functions as Black-Box Abstractions

** 1.2 Procedures Functions and the Processes They Generate

[25]1.2.1 Linear Recursion and Iteration

[26]1.2.2 Tree Recursion

[27]1.2.3 Orders of Growth

[28]1.2.4 Exponentiation

[29]1.2.5 Greatest Common Divisors

[30]1.2.6 Example: Testing for Primality

** 1.3 Formulating Abstractions with Higher-Order Procedures Functions

[34]1.3.1 Procedures Functions as Arguments

[35]1.3.2 Constructing Procedures using Lambda Constructing Functions using Lambda Expressions

[36]1.3.3 Procedures Functions as General Methods

[37]1.3.4 Procedures Functions as Returned Values

* 2 Building Abstractions with Data

** 2.1 Introduction to Data Abstraction

[44]2.1.1 Example: Arithmetic Operations for Rational Numbers

[45]2.1.2 Abstraction Barriers

[46]2.1.3 What Is Meant by Data?

[47]2.1.4 Extended Exercise: Interval Arithmetic

** 2.2 Hierarchical Data and the Closure Property

[51]2.2.1 Representing Sequences

[52]2.2.2 Hierarchical Structures

[53]2.2.3 Sequences as Conventional Interfaces

[54]2.2.4 Example: A Picture Language

** 2.3 Symbolic Data

[58]2.3.1 Quotation Strings

[59]2.3.2 Example: Symbolic Differentiation

[60]2.3.3 Example: Representing Sets

[61]2.3.4 Example: Huffman Encoding Trees

** 2.4 Multiple Representations for Abstract Data

[65]2.4.1 Representations for Complex Numbers

[66]2.4.2 Tagged data

[67]2.4.3 Data-Directed Programming and Additivity

** 2.5 Systems with Generic Operations

[71]2.5.1 Generic Arithmetic Operations

[72]2.5.2 Combining Data of Different Types

[73]2.5.3 Example: Symbolic Algebra

* 3 Modularity, Objects, and State

** 3.1 Assignment and Local State

[80]3.1.1 Local State Variables

[81]3.1.2 The Benefits of Introducing Assignment

[82]3.1.3 The Costs of Introducing Assignment

** 3.2 The Environment Model of Evaluation

[86]3.2.1 The Rules for Evaluation

[87]3.2.2 Applying Simple Procedures Functions

[88]3.2.3 Frames as the Repository of Local State

[89]3.2.4 Internal Definitions Declarations

** 3.3 Modeling with Mutable Data

[93]3.3.1 Mutable List Structure

[94]3.3.2 Representing Queues

[95]3.3.3 Representing Tables

[96]3.3.4 A Simulator for Digital Circuits

[97]3.3.5 Propagation of Constraints

** 3.4 Concurrency: Time Is of the Essence

[101]3.4.1 The Nature of Time in Concurrent Systems

[102]3.4.2 Mechanisms for Controlling Concurrency

** 3.5 Streams

[106]3.5.1 Streams Are Delayed Lists

[107]3.5.2 Infinite Streams

[108]3.5.3 Exploiting the Stream Paradigm

[109]3.5.4 Streams and Delayed Evaluation

[110]3.5.5 Modularity of Functional Programs and Modularity of Objects

* 4 Metalinguistic Abstraction

** 4.1 The Metacircular Evaluator

[117]4.1.1 The Core of the Evaluator

[118]4.1.2 Representing Expressions Components

[119]4.1.3 Evaluator Data Structures

[120]4.1.4 Running the Evaluator as a Program

[121]4.1.5 Data as Programs

[122]4.1.6 Internal Definitions Declarations

[123]4.1.7 Separating Syntactic Analysis from Execution

** 4.2 Variations on a Scheme: Lazy Evaluation

[127]4.2.1 Normal Order and Applicative Order

[128]4.2.2 An Interpreter with Lazy Evaluation

[129]4.2.3 Streams as Lazy Lists

** 4.3 Variations on a Scheme: Nondeterministic Computing

[133]4.3.1 Amb and Search Search and amb

[134]4.3.2 Examples of Nondeterministic Programs

[135]4.3.3 Implementing the Amb amb Evaluator

** 4.4 Logic Programming

[139]4.4.1 Deductive Information Retrieval

[140]4.4.2 How the Query System Works

[141]4.4.3 Is Logic Programming Mathematical Logic?

[142]4.4.4 Implementing the Query System

* 5 Computing with Register Machines

** 5.1 Designing Register Machines

[149]5.1.1 A Language for Describing Register Machines

[150]5.1.2 Abstraction in Machine Design

[151]5.1.3 Subroutines

[152]5.1.4 Using a Stack to Implement Recursion

[153]5.1.5 Instruction Summary

** 5.2 A Register-Machine Simulator

[157]5.2.1 The Machine Model

[158]5.2.2 The Assembler

[159]5.2.3 Generating Execution Procedures for Instructions Instructions and Their Execution Functions

[160]5.2.4 Monitoring Machine Performance

** 5.3 Storage Allocation and Garbage Collection

[164]5.3.1 Memory as Vectors

[165]5.3.2 Maintaining the Illusion of Infinite Memory

** 5.4 The Explicit-Control Evaluator

[169]5.4.1 The Core of the Explicit-Control Evaluator The Dispatcher and Basic Evaluation

[170]5.4.2 Sequence Evaluation and Tail Recursion Evaluating Function Applications

[171]5.4.3 Conditionals, Assignments and Definitions Blocks, Assignments, and Declarations

[172]5.4.4 Running the Evaluator

** 5.5 Compilation

[176]5.5.1 Structure of the Compiler

[177]5.5.2 Compiling Expressions Components

[178]5.5.3 Compiling Combinations Applications and Return Statements

[179]5.5.4 Combining Instruction Sequences

[180]5.5.5 An Example of Compiled Code

[181]5.5.6 Lexical Addressing

[182]5.5.7 Interfacing Compiled Code to the Evaluator
